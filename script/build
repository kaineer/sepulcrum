#!/usr/bin/ruby

$:.unshift( "." )
$:.unshift( "lib" )

require 'rubygems'
require 'yaml'
require "script/lib/utils"

require 'ream/sources/fs'
require 'ream/blog/template_cache__'
require 'ream/blog/template_processor'
require 'ream/blog/overrides/string'

include Utils::Log


module Sepulcrum
  class Build
    
    class SourceHash
      def initialize( obj )
        case obj
        when Hash then init_with_hash( obj )
        when String then init_with_hash( YAML.load( obj ) )
        end
      end

      def init_with_hash( hash )
        @root = hash[ "root" ]
        @mask = hash[ "mask" ]
        @map  = hash[ "map" ]
      end

      attr_reader :root, :mask, :map

      def wildcard
        File.join( root, mask )
      end
    end


    include Utils::Log

    def initialize
      load_template_processors
    end

    def templates
      @templates ||= cache( "templates.source" )
    end

    def pages
      @pages ||= cache( "pages.source" )
    end

  protected

    def sources_config
      @sources_config ||= Ream::Template.scan( "config/sources.tpl" )
    end

    def processors_mask
      SourceHash.
        new( sources_config[ "yaml:processors.source" ] ).wildcard
    end

    def load_template_processors
      info( "load_template_processors" )

      Dir[ processors_mask ].each do |filename|
        debug( "Template processor: #{filename}" )
        require filename unless File.directory?( filename )
      end
      @expanded_build_config = nil
    end

    def expanded_build_config
      @expanded_build_config ||= sources_config.with( Ream::Blog::TemplateProcessor )
    end

    def source( template_name )
      hash = SourceHash.new( expanded_build_config[ template_name ] )
      Ream::Sources::FS.new( hash.root, hash.mask )
    end

    def cache( template_name )
      Ream::Blog::TemplateCache.new( source( template_name ) )
    end
  end
end

sb = Sepulcrum::Build.new
tc = sb.templates

debug( "config:" )
config = tc.fetch( 'blog_page' )[ 'environment' ]
puts config.to_yaml

debug( "blog page layout:" )
page = tc.fetch( 'blog_page' )[ 'html.content' ]
puts page

blog_page = tc.fetch( 'blog_page' )

### list pages
debug( "pages list:" )
puts sb.pages.to_yaml

sb.pages.each do |path, value|
  params = value[ 'parameters' ]
  params = {} unless params.is_a?( Hash )

  environment = value[ 'environment' ]
  debug( environment.inspect )
  blog_page = tc.fetch( *environment[ 'templates' ] )

  styles = blog_page[ 'environment' ][ "stylesheets" ].map{|s|
    s.path.map( "/stylesheets/%a.css" )
  }.map{|s| "<link rel='stylesheet' href='#{s}' type='text/css' />"
  } * $/

  content = blog_page[ 'html.content', 
                  { "content" => value[ "page:content" ] } ]

  html_page = tc.fetch( 'html' )

  debug( styles )
  debug( html_page )
  
  params[ "contents" ] = content
  params[ "html:stylesheets" ] = styles

  

  debug( params.inspect )

  debug( html_page[ "html:page", params ] )

  # of = File.new( path.path.map( "site/%p/%n.html" ), "w" )
  # of.write( html_page[ "html:page", params ] )
  # of.close                    
end

=begin
path = sb.pages.files.first
puts path.path.map( "site/%p/%n.html" )

FileUtils.mkdir_p( path.path.map( "site/%p" ) )

of = File.new( path.path.map( "site/%p/%n.html" ), "w" )
of.write( tc.fetch( 'blog_page.tpl' )[ 'html.content', 
                { "content" => IO.read( path.path.map( "pages/%a" ) ) } 
              ] 
          )
of.close
=end

debug( 'ok.' )
